package com.qssence.backend.authservice.service.implementation;

import org.keycloak.admin.client.Keycloak;
import org.keycloak.admin.client.resource.RealmResource;
import org.keycloak.admin.client.resource.UserResource;
import org.keycloak.admin.client.resource.UsersResource;
import org.keycloak.representations.idm.CredentialRepresentation;
import org.keycloak.representations.idm.UserRepresentation;
import org.springframework.stereotype.Service;

import jakarta.ws.rs.core.Response;
import java.util.List;

@Service
public class KeycloakUserService {

    private final Keycloak keycloak;
    private final String realm = "authrealm";  //this is for server URL https://auth.qssence.com/auth/realms/authrealm

    public KeycloakUserService(Keycloak keycloak) {
        this.keycloak = keycloak;
    }

    // ================= CREATE USER =================
    public String createKeycloakUser(String email, String password, String firstName, String lastName) {
        try {
            UserRepresentation user = new UserRepresentation();
            user.setEnabled(true);
            user.setUsername(email);
            user.setEmail(email);
            user.setFirstName(firstName);
            user.setLastName(lastName);
            user.setEmailVerified(true);

            // Create request
            UsersResource usersResource = keycloak.realm(realm).users();
            Response response = usersResource.create(user);

            if (response.getStatus() == 201) {
                // ✅ User created successfully
                String userId = response.getLocation().getPath().replaceAll(".*/([^/]+)$", "$1");

                // ✅ Immediately set password so it is saved properly
                setUserPassword(userId, password, false);
                return userId;

            } else if (response.getStatus() == 409) {
                // ✅ User already exists → fetch userId
                List<UserRepresentation> existingUsers = usersResource.search(email, true);
                if (!existingUsers.isEmpty()) {
                    String userId = existingUsers.get(0).getId();

                    // ✅ Reset password for existing user with autogenerated one
                    setUserPassword(userId, password, false);
                    return userId;
                }
                throw new RuntimeException("User already exists but could not fetch userId from Keycloak");
            } else {
                String errorMessage = "Failed to create user in Keycloak. Status: " + response.getStatus();
                if (response.hasEntity()) {
                    try {
                        String responseBody = response.readEntity(String.class);
                        errorMessage += ". Response: " + responseBody;
                    } catch (Exception e) {
                        errorMessage += ". Could not read response body";
                    }
                }
                throw new RuntimeException(errorMessage);
            }
        } catch (Exception e) {
            // ✅ Better error handling with specific messages
            if (e.getMessage().contains("UnrecognizedPropertyException")) {
                throw new RuntimeException("Keycloak version compatibility issue. Please check Keycloak client version. Error: " + e.getMessage());
            } else if (e.getMessage().contains("Connection refused")) {
                throw new RuntimeException("Cannot connect to Keycloak server. Please check if Keycloak is running and accessible.");
            } else if (e.getMessage().contains("401") || e.getMessage().contains("403")) {
                throw new RuntimeException("Keycloak authentication failed. Please check admin credentials and permissions.");
            } else {
                throw new RuntimeException("Keycloak user creation failed: " + e.getMessage());
            }
        }
    }

    // ================= SET PASSWORD (internal helper) =================
    private void setUserPassword(String userId, String password, boolean temporary) {
        CredentialRepresentation credential = new CredentialRepresentation();
        credential.setTemporary(temporary);  // false = permanent, true = user must reset on first login
        credential.setType(CredentialRepresentation.PASSWORD);
        credential.setValue(password);

        keycloak.realm(realm).users().get(userId).resetPassword(credential);
    }

    // ================= UPDATE USER =================
    public void updateKeycloakUser(String userId, String newEmail, String firstName, String lastName, String newPassword) {
        RealmResource realmResource = keycloak.realm(realm);
        UsersResource usersResource = realmResource.users();
        UserResource userResource = usersResource.get(userId);

        UserRepresentation user = userResource.toRepresentation();

        if (newEmail != null && !newEmail.isEmpty()) {
            user.setEmail(newEmail);
            user.setUsername(newEmail);
        }
        if (firstName != null && !firstName.isEmpty()) {
            user.setFirstName(firstName);
        }
        if (lastName != null && !lastName.isEmpty()) {
            user.setLastName(lastName);
        }

        userResource.update(user);

        // ✅ Update password if provided
        if (newPassword != null && !newPassword.isEmpty()) {
            setUserPassword(userId, newPassword, false);
        }
    }

    // ================= DELETE USER =================
    public void deleteUser(String userId) {
        try {
            keycloak.realm(realm).users().get(userId).remove();
        } catch (Exception e) {
            throw new RuntimeException("Failed to delete user in Keycloak: " + e.getMessage(), e);
        }
    }

    // ================= RESET PASSWORD (for forgot password flow) =================
    public void resetUserPassword(String userId, String newPassword) {
        // ✅ This will allow user to change password if forgotten
        setUserPassword(userId, newPassword, false);
    }

    // ================= FORCE USER TO RESET PASSWORD ON NEXT LOGIN =================
    public void forcePasswordResetOnNextLogin(String userId, String tempPassword) {
        // ✅ If you want user to be forced to change password on next login
        setUserPassword(userId, tempPassword, true);
    }

    // ================= FIND USER BY EMAIL =================
    public UserRepresentation findUserByEmail(String email) {
        List<UserRepresentation> users = keycloak.realm(realm).users().search(email, true);
        return users.isEmpty() ? null : users.get(0);
    }

//    // ================= DISABLE USER =================
//    public void disableUser(String email) {
//        try {
//            UserRepresentation user = findUserByEmail(email);
//            if (user != null) {
//                user.setEnabled(false);
//                keycloak.realm(realm).users().get(user.getId()).update(user);
//                log.info("User disabled: {}", email);
//            }
//        } catch (Exception e) {
//            throw new RuntimeException("Failed to disable user: " + e.getMessage(), e);
//        }
//    }
//
//    // ================= ENABLE USER =================
//    public void enableUser(String email) {
//        try {
//            UserRepresentation user = findUserByEmail(email);
//            if (user != null) {
//                user.setEnabled(true);
//                keycloak.realm(realm).users().get(user.getId()).update(user);
//                log.info("User enabled: {}", email);
//            }
//        } catch (Exception e) {
//            throw new RuntimeException("Failed to enable user: " + e.getMessage(), e);
//        }
//    }
}
